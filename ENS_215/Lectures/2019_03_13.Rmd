---
title: "Maps in R: Continued"
author: "ENS-215"
date: "13-Mar-2019"
output:
  html_document:
    df_print: paged
    theme: spacelab
    toc: yes
    toc_float: yes
---

<br/> 

In the last lesson we learned about some basic concepts related to spatial data (_e.g._ projections and data types) and some of the basics of handling and displaying spatial data in R.  In that lesson we saw how to generate maps using data from the `maps` package and the plotting functions from the `ggplot2` package.  We also learned how to bring layer data on to a map -- we created a point map showing recent earthquakes and a choropleth map showing temperature data for each US state.  

As we saw the `ggplot2` package allows you to create high-quality maps (there is much more functionality than we were able to cover in one class) and you could easily do much of your map making work in `ggplot2`.  However, there are many other packages/tools available for creating maps in R and it is worthwhile to be introduced to two highly useful and widely used packages -- `leaflet` and `tmap`.  The `leaflet` and `tmap` packages, allow you to create both interactive (`leaflet` and `tmap`) and static maps (`tmap`) and will expand the map making tools at your disposal.  

Again, I strongly recommend those of you who are interested to map making (and spatial analysis more broadly) to consult the excellent and freely available textbook [Geocomputation with R](https://geocompr.robinlovelace.net/).  


## Interactive maps with `leaflet`
Leaflet is a very popular, open-source library for creating interactive maps.  You've almost certainly interacted Leaflet maps before as they are widely used by The US National Parks Service, The New York Times and The Washington Post, along with a host of other popular sites.  You can easily generate Leaflet maps in R using the `leaflet` package.  

Let's first load in the `leaflet` package, which we will use to make interactive maps.  We'll also load in the `tidyverse` package, since we will use some of its data wrangling/handling packages.  
```{r}
library(leaflet)
library(tidyverse)
```


With Leaflet you can quickly load in a basemap image (tile) into the interactive map widget.  

To do this you call the `leaflet()` function, which create the map widget and then call the `addTiles()` function, which loads in a basemap tile (_i.e._ a basemap image).

Let's give that a try.  The code below will bring up an interactive map in your **Viewer** pane.  After running the code take a minute to interact with the map widget to get familiar with its functionality.  
```{r}
leaflet() %>% 
  addTiles()
```

Notice that unlike in `ggplot2`, we add additional functions to the leaflet call using the pipe `%>%` operator and NOT a `+`. 

<br/>

The default basemap tile (OpenStreetMap) is suitable for some applications, though in many cases you will want to use a different map tile.  Leaflet provides access to a range of different basemap tiles -- providing basemaps that suit a wide-range of applications.

The basemap tiles available in Leaflet are listed [here](http://leaflet-extras.github.io/leaflet-providers/preview/).  Take a look at the link to see all of the options.  

The `addProviderTiles()` function allows you to specify the basemap tile you want to use.  Let's illustrate this with an example.  We'll us the National Geographic basemap.
```{r}
leaflet() %>% 
  addProviderTiles(providers$Esri.NatGeoWorldMap)
```

Try out a few other map tiles of interest.  Note: some provider tiles do not knit properly or show up in the Viewer pane.  It seems to be an RStudio issue, as the map will generally appear properly when you show it in a web browser window.  


<br/>

### Adding layers/geometries to Leaflet maps
So far we've just generated a basemap, however we almost always want to display additional layers of data on top of the basemap.  We can easily use data from a range of data formats (e.g. data frames, `sp` and `sf` objects, GeoJSON) display a range of geometries (e.g. point markers, polygons, lines, ...).  


#### Markers
Let's load in the locations of the US state capitals and save the data to a data frame.
```{r message=FALSE}
state_cap_locs <- read_csv("https://stahlm.github.io/ENS_215/Data/us_capitals_locs.csv", skip = 2)

state_cap_locs <- state_cap_locs %>% 
  filter(state_cd %in% state.abb) %>% # remove locations that aren't US state list (e.g. Puerto Rico, Guam, ...)
  filter(state_cd != "AK", state_cd != "HI") # remove capitals of Alaska and Hawaii (our basemap only has the lower 48 states)
```


We can now generate a leaflet map where we show the location of each capital as a marker. 
```{r eval=T}
map_cap <- leaflet(data = state_cap_locs) %>% 
  #addTiles() %>% 
  addProviderTiles(providers$Esri.NatGeoWorldMap) %>% 
  addMarkers(lng = ~long_deg, lat = ~lat_deg, label = ~state_cd)


```
Note the syntax in the `addMarkers()` function.  We assign the latitude and longitude aesthetics using `lng =~ Name_of_datafram_col`.  Where `Name_of_datafram_col` is the name of the column in our `state_cap_locs` data frame that has the variable interest.  We also assigned the variable `state_cd` from the `state_cap_locs` data frame to the label aesthetic.  You will see the state abbreviation will appear when you hover over a given state capital's marker . 

Note that we assign the variable to the aesthetic using `=~`.  In `leaflet` variables are mapped to aesthetics using that syntax. 

Also note that just like graphics generated with `ggplot2`, we can similarly assign the graphic to an R object, in this case `map_cap`.  We'll now display `map_cap`
```{r}
map_cap
```

There are a number of other marker features that you can adjust, including the marker icon used and marker size.  For additional information and examples, check out the [Leaflet for R](http://rstudio.github.io/leaflet/) website.

+ Create another version of the above map where you adjust some of the marker features.

<br/>

#### Circles
Another useful geometry to add to leaflet maps are circles, which are added using the `addCircles()` function.  Circles can be particularly useful in certain situations, given that the radii of the circles are specified in meters and thus the circle will scale accordingly as you zoom in and out.  This differs from markers, which have a fixed pixel size and thus the size of the marker area to a given geographical area changes as you zoom in and out.  
One particularly useful application of the cirles geometry in Leaflet is for creating circular buffers around regions.  For instance you might want to map a 10 km radius around a nuclear power plant to help visualize the areas most likely to be affected during an emergency.  

Let's illustrate the use of circles with an example.  Around each US state capital we will create circles with at 30 km radius.  This could be useful if we interested in seeing the regions with relatively easy travel distance to each US state capital. Note that the `radius` is set in units of meters.

```{r}
leaflet(state_cap_locs) %>% 
  addTiles() %>% 
  addCircles(lng = ~long_deg, lat = ~lat_deg, radius = 30*10^3, fillColor = "transparent")
```


<br/>

#### Polygons
In addition to markers and circles, displaying polygons is often required.  A common situation where this is needed is when displaying border/boundaries of regions (_e.g._ states, countries, national parks,...).  

Let's load in a dataset containing polygons outlining the border of each US state.  The data we will load in is in GeoJSON format.  GeoJSON is a standarized format for representing simple geographic features (_e.g. points, lines, polygons) along with their non-spatial attributes (_e.g. location names, populations,...).  When you download spatial data in your work you will find that it is often in GeoJSON or shapefile format (another very common file format for spatial data).  

In order to load GeoJSON data into R we will need to use the `geojsonio` package.  
```{r message=FALSE, warning=FALSE}
library(geojsonio)
```



Now we will use the `geojson_read()` function to load in the **.geojson** file that has the state boundaries.  You can see that we've set the `what` argument equal to `"sp"`.  This tells the `geojson_read()` function to convert the GeoJSON file into a **Spatial data-structure** that can be easily computed on, manipultate, and plotted in many R packages including Leaflet.
```{r}
state_borders <- geojson_read("../Class_Data/gz_2010_us_040_00_5m.geojson", what = "sp")

# geojson state boundaries from http://eric.clst.org/tech/usgeojson/
```


Let's now add the state polygons to our map with the state capitals.  We can add the polygons using the `addPolygons()` function in `leaflet`.  Notice that we need to specify within the `addPolygons()` function call the dataset where the polygon data is stored.  
```{r}
map_cap %>% 
  addPolygons(data = state_borders)
```



### Controlling map layers
Oftentimes you will want to give yourself (or other users) the ability to interactively toggle map layers on and off and to change the basemap between different map tiles.  You can easily do this with the  `addLayersControl()` function in leaflet.  

Let's create our map with the state border polygons and state capital markers.  This time we will also load in three different basemap tiles.  We will use the `addLayersControl()` function to allow us to toggle between the basemap and layers in the map we create.  Note that each of the geometry layers (markers and polygons) and each of the tile layers are assigned to a `group` with a name of our choosing.  The group provides a unique identifier for each layer which is used in the `addLayersControl()` to specifiy the layers that we will allow to be toggled between.  
```{r}
leaflet(state_cap_locs) %>% 
  addTiles(group = "OSM") %>%
  addProviderTiles(providers$Stamen.Toner, group = "Toner") %>% 
  addProviderTiles(providers$Stamen.Watercolor, group = "Watercolor") %>% 
  addMarkers(lng = ~long_deg, lat = ~lat_deg, label = ~state_cd, group = "Capitals") %>% 
  addPolygons(data = state_borders, group = "Borders") %>% 
  
  addLayersControl(
    baseGroups = c("OSM", "Toner","Watercolor"),   # specify the base map groups that we can toggle between
    overlayGroups = c("Capitals", "Borders"),   # specify the geometry layer groups that we can toggle between
    options = layersControlOptions(collapsed = FALSE) 
  )

```


+ Try creating one or two maps of your own using the techniques learned in the section above.  Many of you will likely want to create an interactive map for your final project (now's your chance to give it a try!).

<br/>


### Making maps with the `tmap` package
The `tmap` package is a widely used package for creating both static and interactive maps in R.  The `tmap` package have a wide range of functionality and flexibility and allows for the display of more spatial classes than `ggplot2` -- thus allowing for certain types of maps that are difficult to create with `ggplot2`.  A nice feature of the `tmap` package is that it is based on the "grammar of graphics" and thus the syntax is very similar to `ggplot2`.  This makes learning `tmap` relatively easy for those who already have experience with `ggplot2` (_i.e._ you).  


Let's load in the `tmap` package, along with the `spData` package which has provides some nice spatial datasets that we can use to create example maps.  We will also load in the `sf` package, which provides functionality in R for Simple Features data types.
```{r message=FALSE, warning=FALSE}
library(tmap)
library(spData)
library(sf)
```

https://github.com/r-spatial/sf

```{r}
library(tmap)
tm_shape(world) +
    tm_polygons("lifeExp")
```


```{r}
tmap_mode("plot")
tm_shape(world) +
  tm_fill() +
  tm_borders() +
  tm_facets(by = "continent", free.coords = T)
```


https://github.com/stahlm/stahlm.github.io/raw/master/ENS_215/Data/Rivers.zip
```{r}
shape_river <- st_read("../Class_Data/Rivers/ne_50m_rivers_lake_centerlines.shp", stringsAsFactors = FALSE)

```


```{r}
tmap_mode("plot")
tm_shape(world) +
  tm_fill() +
  tm_borders() +
  tm_style("natural") +
  tm_shape(shape_river) +
  tm_lines(col = "blue") 
  
  
```




```{r eval=T}
tmap_mode("view")
tm_shape(world) +
  tm_fill() +
  tm_borders() +
  tm_style("natural") +
  tm_shape(shape_river) +
  tm_lines(col = "blue") +
  tm_view(basemaps = "Esri.WorldPhysical")

```


https://www.azavea.com/blog/2017/08/30/spatial-analysis-pipelines-in-r-with-simple-features/